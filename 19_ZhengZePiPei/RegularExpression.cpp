#include<iostream>
#include<string>
using namespace std;

/*题解：假设主串是A，模式串B从最后一步出发，需要关注最后进来的字符，假设A的长度n，B
的长度m，关注正则表达式的最后一个字符是谁。他有三种可能 正常字符  .  * 分别讨论
1. 如果B的最后一个字符是正常字符，那就看A[n-1]是否等于B[m-1] ,相等就比较A0..n-2和B0..m-2
不等就是不能匹配
2. 如果B的最后一个字符是. 他能匹配任意的字符，直接看A0..n-2和B0..m-2
3. 如果B的最后一个字符是*,他代表B[m-2]=c可以重复0次或者多次,他们是一个整体c*
情况1：A[n-1]是0个c,B的最后两个字符废了，取决于A0..n-1,B0..m-3是否匹配
情况2：A[n-1]是多个c中的最后1个(这种情况A[n-1] = c或者c=.),A匹配完成往前移动一位，B继续
匹配，可以匹配多个，继续看A0..n-2和B0..m-1是否匹配


f[i][j] 代表 A 的前 i个和 B 的前 j 个能否匹配
对于前面两个情况，可以合并成一种情况 f[i][j] =f[i−1][j−1]
对于第三种情况，对于 c*c∗ 分为看和不看两种情况
不看：直接砍掉正则串的后面两个， f[i][j] =f[i][j−2]
看：正则串不动，主串前移一个，f[i][j] =f[i−1][j]



特判：需要考虑空串空正则

空串和空正则是匹配的，f[0][0] = truef[0][0]=true
空串和非空正则，不能直接定义 truetrue 和 falsefalse，必须要计算出来。
（比如A=A= '' '' ,B=a*b*c*B=a∗b∗c∗）
非空串和空正则必不匹配，f[1][0]=...=f[n][0]=falsef[1][0]=...=f[n][0]=false
非空串和非空正则，那肯定是需要计算的了。


*/

bool isMatch(string A,string B)
{
	int n = A.length();
	int m = B.length();

	vector<vector<bool>>dp(n+1,vector<int>(m+1),false);

	for(int i=0;i<=n;i++)
	{
		for(int j=0;j<=m;j++)
		{
			if(j == 0)  //分为非空正则和空正则两种
			{
				dp[i][j] =( i == 0);
			}
			else{   //非空正则分为两种情况* 和 非*
				
				if(B[j-1]!='*'){
					if(i>0 && (A[i-1]==B[j-1] || B[j-1]=='.')){ //括号要注意
						dp[i][j]=dp[i-1][j-1];
					}
				}else{  //配到了*
					if(j>=2){  //不看
						dp[i][j] = dp[i][j] ||  dp[i][j-2];
					}
					//看
					if(i>=1&&j>=2&&(A[i-1]==B[j-2]||B[j-2]=='.')){ //括号要注意
						dp[i][j] =dp[i][j] ||  dp[i-1][j];
					}
				}
			}
		}
	}
	return dp[n][m];
}

int main()
{
	return 0;
}
